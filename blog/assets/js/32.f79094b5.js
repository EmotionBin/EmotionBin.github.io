(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{404:function(t,_,v){"use strict";v.r(_);var e=v(46),r=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"扫码登录原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#扫码登录原理"}},[t._v("#")]),t._v(" 扫码登录原理")]),t._v(" "),v("p",[t._v("二维码扫码登录是我们非常常见的一个场景，今天就来聊一聊扫码登录")]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"主要流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要流程"}},[t._v("#")]),t._v(" 主要流程")]),t._v(" "),v("p",[t._v("这种操作常见于以下场景：你已经在手机设备登录的情况下，需要在电脑 PC 端应用或者网页也登录，这时，如果该应用支持扫码登录，我们就可以拿出手机，扫描 PC 端生成的一个二维码，在手机上确认登录，PC 端就可以登录了")]),t._v(" "),v("p",[t._v("比如 QQ 扫码登录、微信扫码登录、微博扫码登录等等")]),t._v(" "),v("p",[t._v("现在假设：手机端已经登录了微信，这时候需要在 PC 端也登录")]),t._v(" "),v("ol",[v("li",[t._v("PC 端生成一个二维码，等待扫描")]),t._v(" "),v("li",[t._v("使用手机端微信的扫一扫功能扫描二维码")]),t._v(" "),v("li",[t._v("手机端解析二维码并弹出确认登录弹窗，此时 PC 端的二维码状态显示为：已扫描，等待确认")]),t._v(" "),v("li",[t._v("手机端点击确认登录，这时 PC 端的微信完成登录")])]),t._v(" "),v("hr"),t._v(" "),v("h2",{attrs:{id:"具体实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#具体实现"}},[t._v("#")]),t._v(" 具体实现")]),t._v(" "),v("p",[t._v("扫码登录的整个过程中主要有以下几个关键点：")]),t._v(" "),v("ul",[v("li",[t._v("在扫码登录整个过程中，手机端和 PC 端是否需要有数据传输")]),t._v(" "),v("li",[t._v("在手机端进行确认登录的时候，为什么 PC 端就能直接登录")]),t._v(" "),v("li",[t._v("如何保证扫码登录的过程是安全的，非信息暴露泄漏的")]),t._v(" "),v("li",[t._v("PC 端是如何检测到二维码的状态的（已扫描、已取消、已确认等）")])]),t._v(" "),v("p",[v("strong",[t._v("在扫码登录整个过程中，手机端和 PC 端是否需要有数据传输")])]),t._v(" "),v("p",[t._v("答案是肯定的，手机端和 PC 端是有数据交互的，否则 PC 端是无法进行登录操作的")]),t._v(" "),v("p",[t._v("那到底是什么数据在进行交互呢？答案是：一种仅用于扫码登录的临时 token 令牌数据")]),t._v(" "),v("p",[t._v("PC 端在生成二维码的时候，向服务端发送一个生成二维码的请求，服务端会生成一个 ID，然后把这个 ID 绑定到生成的二维码里面，再把这个二维码返回给 PC 端，PC 端就会显示这个绑定了 ID 的二维码并且等待扫描")]),t._v(" "),v("p",[t._v("当手机设备扫描二维码后，会解析二维码并拿到这个 ID，通过二维码把这个 ID 从 PC 端传输到了手机端，所以手机端和 PC 端是需要有数据传输的")]),t._v(" "),v("p",[v("strong",[t._v("在手机端进行确认登录的时候，为什么 PC 端就能直接登录")])]),t._v(" "),v("p",[t._v("继续前面说的，手机端进行确认登录的时候，会带着这个 ID，以及手机端上已经登录了的用户身份信息 token，一起发送给服务器，服务器接收到后，新生成一个专门给 PC 端使用且绑定了用户身份的 token，然后把这个新的 token 返回给 PC 端，PC 端拿到新的 token 后就相当于登录了，根据这个 token 就可以和服务端通信了")]),t._v(" "),v("p",[v("strong",[t._v("如何保证扫码登录的过程是安全的，非信息暴露泄漏的")])]),t._v(" "),v("p",[t._v("在整个扫码登录过程中，手机端与 PC 端涉及的数据交互，仅仅是由服务器管理控制的一个二维码 ID、手机端上的用户身份 token（有时效性）、服务器新生成给 PC 端的用户身份 token（有时效性），没有敏感信息交互，也就不存在敏感信息的泄漏；服务器给 PC 端生成一个新的 token，从另一个角度上看，就跟用户输入用户名密码登录的本质是一样的，都是基于带时效性的 token 校验机制，只不过扫码登录的方式少了输入用户名密码这一个步骤。因此，这样的一个扫码登录流程是安全的")]),t._v(" "),v("p",[v("strong",[t._v("PC 端是如何检测到二维码的状态的（已扫描、已取消、已确认等）")])]),t._v(" "),v("p",[t._v("无非两种方式：socket 和轮询")]),t._v(" "),v("p",[t._v("socket 方式：")]),t._v(" "),v("p",[t._v("PC 端保持着与服务器的长连接，当手机端扫描二维码后，带着解析得到的二维码 ID 第一次发送给服务器，当服务器收到这个请求后，代表用户已经扫描了二维码，这时服务器就可以通过 socket 告知 PC 端二维码已被扫描，等待确认；之后手机端不论是取消登录还是确认登录，都会相应的请求服务器，服务器收到请求会根据相应的逻辑处理，进而通知 PC 端更新相应的状态")]),t._v(" "),v("p",[t._v("轮询方式：")]),t._v(" "),v("p",[t._v("轮询方式即在 PC 端创建一个定时器，每隔一段时间请求服务器查询状态的更新情况，然后更新网页的显示信息。但是这个定时器得控制好启动时机和生命周期，因为 PC 端的二维码有可能一直没有被扫描，或者扫描之后没有下一步操作了，这时，如果没有控制好这个定时器，PC 端就会一直地请求服务器查询，造成资源浪费和一定的性能损耗")]),t._v(" "),v("p",[t._v("至此，二维码扫码登录的分析我们已经基本了解了，接下来我们用时序图来描述二维码扫码登录的详细流程：")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://z3.ax1x.com/2021/11/21/IX4uDO.png",target:"_blank",rel:"noopener noreferrer"}},[v("img",{attrs:{src:"https://z3.ax1x.com/2021/11/21/IX4uDO.png",alt:"IX4uDO.png"}}),v("OutboundLink")],1)]),t._v(" "),v("p",[v("strong",[t._v("参考资料：")])]),t._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/h_xiao_x/article/details/105920831",target:"_blank",rel:"noopener noreferrer"}},[t._v("二维码扫码登录原理"),v("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);